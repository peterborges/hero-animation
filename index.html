<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dither Shader Editor</title>
  <link rel="stylesheet" href="https://unpkg.com/tweakpane@3.1.6/dist/tweakpane.min.css" crossorigin="">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #000; overflow: hidden; cursor: crosshair; }
    #canvas { display: block; width: 100vw; height: 100vh; image-rendering: pixelated; }
    .tp-dfwv { width: 280px !important; }

    /* â”€â”€ Preset panel â”€â”€ */
    #preset-panel {
      position: fixed;
      top: 0; right: 296px;
      width: 220px;
      background: #1f1f1f;
      border: 1px solid #3a3a3a;
      border-radius: 6px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      font-size: 11px;
      color: #ccc;
      z-index: 9999;
      display: flex;
      flex-direction: column;
      max-height: 90vh;
    }
    #preset-panel header {
      padding: 8px 10px 6px;
      font-weight: 600;
      font-size: 11px;
      color: #fff;
      border-bottom: 1px solid #3a3a3a;
      display: flex;
      align-items: center;
      justify-content: space-between;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }
    #preset-panel header span { opacity: 0.4; font-size: 10px; font-weight: 400; text-transform: none; }
    #preset-save-row {
      display: flex;
      gap: 4px;
      padding: 7px 8px;
      border-bottom: 1px solid #2a2a2a;
    }
    #preset-name-input {
      flex: 1;
      background: #111;
      border: 1px solid #3a3a3a;
      border-radius: 3px;
      color: #eee;
      font-size: 11px;
      padding: 4px 6px;
      outline: none;
    }
    #preset-name-input:focus { border-color: #666; }
    #preset-save-btn {
      background: #2d6af0;
      border: none;
      border-radius: 3px;
      color: #fff;
      font-size: 11px;
      padding: 4px 8px;
      cursor: pointer;
      white-space: nowrap;
    }
    #preset-save-btn:hover { background: #3d7aff; }
    #preset-list {
      overflow-y: auto;
      flex: 1;
    }
    .preset-item {
      display: flex;
      align-items: center;
      padding: 5px 8px;
      border-bottom: 1px solid #2a2a2a;
      gap: 4px;
    }
    .preset-item:hover { background: #2a2a2a; }
    .preset-load-btn {
      flex: 1;
      background: none;
      border: none;
      color: #ddd;
      font-size: 11px;
      text-align: left;
      cursor: pointer;
      padding: 2px 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .preset-load-btn:hover { color: #fff; }
    .preset-export-btn, .preset-delete-btn {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 13px;
      padding: 2px 3px;
      line-height: 1;
      opacity: 0.5;
      border-radius: 3px;
    }
    .preset-export-btn:hover { opacity: 1; background: #333; }
    .preset-delete-btn:hover { opacity: 1; background: #500; }
    #preset-empty {
      padding: 12px 10px;
      color: #555;
      font-style: italic;
      text-align: center;
    }
    #preset-import-row {
      padding: 6px 8px;
      border-top: 1px solid #2a2a2a;
    }
    #preset-import-btn {
      width: 100%;
      background: #2a2a2a;
      border: 1px solid #3a3a3a;
      border-radius: 3px;
      color: #aaa;
      font-size: 11px;
      padding: 4px 8px;
      cursor: pointer;
      text-align: center;
    }
    #preset-import-btn:hover { background: #333; color: #fff; }
    #preset-toast {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: #2d6af0;
      color: #fff;
      font-size: 12px;
      padding: 7px 16px;
      border-radius: 20px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 99999;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }
    #preset-toast.show { opacity: 1; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <div id="preset-panel">
    <header>Presets <span>localStorage</span></header>
    <div id="preset-save-row">
      <input id="preset-name-input" type="text" placeholder="Name this presetâ€¦" maxlength="40">
      <button id="preset-save-btn">Save</button>
    </div>
    <div id="preset-list"></div>
    <div id="preset-import-row">
      <button id="preset-import-btn">â¬† Import JSON</button>
      <input id="preset-import-file" type="file" accept=".json" style="display:none">
    </div>
  </div>
  <div id="preset-toast"></div>

  <script src="https://unpkg.com/tweakpane@3.1.6/dist/tweakpane.min.js" crossorigin=""></script>
  <script>
  document.addEventListener('DOMContentLoaded', function () {

    // â”€â”€â”€ Canvas setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let W, H, PW, PH;

    function resize() {
      W = window.innerWidth;
      H = window.innerHeight;
      canvas.width  = W;
      canvas.height = H;
      PW = Math.ceil(W / params.pixelScale);
      PH = Math.ceil(H / params.pixelScale);
    }

    // â”€â”€â”€ Parameters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const params = {
      // Pixel grid
      pixelScale:    6,       // display pixels per "dither pixel"

      // Dither algorithm
      ditherMode:    'bluenoise',  // 'ordered' | 'bluenoise' | 'voidcluster' | 'none'
      matrixSize:    4,          // 2 | 4 | 8  (Bayer matrix)
      threshold:     0.5,

      // Luminance field (what gets dithered)
      fieldMode:     'plasma',   // 'plasma' | 'radial' | 'noise' | 'bands'
      speed:         0.25,
      scale:         1.0,
      octaves:       3,
      contrast:      1.0,
      bias:          0.0,

      // Temporal smoothing â€” lerp factor per frame (0=frozen, 1=instant)
      smoothing:     0.08,

      // Cursor interaction
      cursorRadius:  120,
      cursorStrength: 0.6,
      cursorMode:    'brighten', // 'brighten' | 'darken' | 'invert' | 'ripple'

      // Colors
      dotColor:      { r: 255, g: 255, b: 255 },
      bgColor:       { r: 0,   g: 0,   b: 0   },

      // Dot shape rendered per pixel-cell
      dotShape:      'circle',   // 'circle' | 'square' | 'cross'
      dotFill:       1.0,        // 0..1 â€” how much of cell to fill
    };

    window.addEventListener('resize', resize);

    // â”€â”€â”€ Mouse â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let mxPx = window.innerWidth / 2, myPx = window.innerHeight / 2; // pixel coords
    let rippleT = 0;

    document.addEventListener('mousemove', e => {
      mxPx = e.clientX;
      myPx = e.clientY;
    });

    document.addEventListener('click', () => { rippleT = 0; });

    // â”€â”€â”€ Bayer matrices â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const BAYER = {
      2: [
        [0, 2],
        [3, 1],
      ],
      4: [
        [ 0,  8,  2, 10],
        [12,  4, 14,  6],
        [ 3, 11,  1,  9],
        [15,  7, 13,  5],
      ],
      8: (() => {
        const b4 = [
          [ 0,  8,  2, 10], [12,  4, 14,  6],
          [ 3, 11,  1,  9], [15,  7, 13,  5],
        ];
        const m = [];
        for (let y = 0; y < 8; y++) {
          m[y] = [];
          for (let x = 0; x < 8; x++) {
            const qy = Math.floor(y / 2), qx = Math.floor(x / 2);
            const ry = y % 2, rx = x % 2;
            m[y][x] = b4[qy][qx] * 4 + b4[ry][rx];
          }
        }
        return m;
      })(),
    };

    // â”€â”€â”€ Noise helpers (simple value noise) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function hash(n) {
      // cheap but decent hash
      let x = Math.sin(n) * 43758.5453123;
      return x - Math.floor(x);
    }
    function noise2(x, y) {
      const ix = Math.floor(x), iy = Math.floor(y);
      const fx = x - ix, fy = y - iy;
      const ux = fx * fx * (3 - 2 * fx);
      const uy = fy * fy * (3 - 2 * fy);
      const n00 = hash(ix     + iy     * 57.0);
      const n10 = hash(ix + 1 + iy     * 57.0);
      const n01 = hash(ix     + (iy+1) * 57.0);
      const n11 = hash(ix + 1 + (iy+1) * 57.0);
      return n00*(1-ux)*(1-uy) + n10*ux*(1-uy) + n01*(1-ux)*uy + n11*ux*uy;
    }
    function fbm(x, y, oct) {
      let v = 0, a = 0.5, f = 1;
      for (let i = 0; i < oct; i++) {
        v += a * noise2(x * f, y * f);
        a *= 0.5; f *= 2.1;
      }
      return v;
    }

    // â”€â”€â”€ Luminance field â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function sampleField(px, py, t) {
      // px, py are pixel buffer coords; return 0..1 luminance
      const nx = (px / PW) * params.scale;
      const ny = (py / PH) * params.scale;
      const speed = params.speed;
      let v;

      switch (params.fieldMode) {
        case 'plasma':
          v  = Math.sin(nx * 3.1 + t * speed);
          v += Math.sin(ny * 2.7 - t * speed * 0.7);
          v += Math.sin((nx + ny) * 2.0 + t * speed * 0.5);
          v += Math.sin(Math.sqrt((nx - 0.5*params.scale)**2 + (ny - 0.5*params.scale)**2) * 4);
          v = (v + 4) / 8;
          break;

        case 'radial': {
          const cx = params.scale * 0.5;
          const cy = params.scale * 0.5;
          const r = Math.sqrt((nx - cx)**2 + (ny - cy)**2);
          v = 0.5 + 0.5 * Math.sin(r * 5 - t * speed);
          break;
        }

        case 'noise':
          v = fbm(nx + t * speed * 0.3, ny + t * speed * 0.2, params.octaves);
          break;

        case 'bands':
          v = 0.5 + 0.5 * Math.sin(nx * 4 + t * speed + Math.sin(ny * 2 + t * speed * 0.5) * 2);
          break;

        default:
          v = 0.5;
      }

      // contrast + bias
      v = (v - 0.5) * params.contrast + 0.5 + params.bias;
      return Math.max(0, Math.min(1, v));
    }

    // â”€â”€â”€ Cursor influence â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function cursorInfluence(px, py, t, v) {
      const sx = px / PW * W;
      const sy = py / PH * H;
      const dx = sx - mxPx;
      const dy = sy - myPx;
      const dist = Math.sqrt(dx*dx + dy*dy);
      const r = params.cursorRadius;
      if (dist >= r) return v;

      const strength = (1 - dist / r) ** 2 * params.cursorStrength;

      switch (params.cursorMode) {
        case 'brighten': return Math.min(1, v + strength);
        case 'darken':   return Math.max(0, v - strength);
        case 'invert':   return v + (1 - 2*v) * strength;
        case 'ripple': {
          const wave = Math.sin(dist * 0.2 - t * 4) * 0.5 + 0.5;
          return Math.max(0, Math.min(1, v + (wave - 0.5) * strength));
        }
        default: return v;
      }
    }

    // â”€â”€â”€ Blue noise texture (64Ã—64, void-and-cluster approximation) â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Generated via a seeded, iterative void-and-cluster algorithm offline.
    // Using it as a spatially well-distributed, aperiodic threshold mask gives
    // far better temporal stability than scan-line error diffusion.
    const BN_SIZE = 64;
    const blueNoise = (() => {
      // Approximate blue noise via a multi-pass rank shuffle of white noise
      // seeded deterministically â€” good enough for animation dithering.
      const N = BN_SIZE * BN_SIZE;
      const arr = new Float32Array(N);

      // Seed with low-discrepancy white noise
      let s = 1234567;
      function rng() { s = (s * 1664525 + 1013904223) & 0xffffffff; return (s >>> 1) / 0x7fffffff; }
      for (let i = 0; i < N; i++) arr[i] = rng();

      // Three rounds of Gaussian-filtered rank sort (void-and-cluster approximation)
      const sigma = 1.9;
      const kR    = Math.ceil(sigma * 3);
      const tmp   = new Float32Array(N);

      function gaussBlur(src, dst) {
        const W = BN_SIZE, H = BN_SIZE;
        for (let y = 0; y < H; y++) {
          for (let x = 0; x < W; x++) {
            let sum = 0, w = 0;
            for (let dy = -kR; dy <= kR; dy++) {
              for (let dx = -kR; dx <= kR; dx++) {
                const g = Math.exp(-(dx*dx + dy*dy) / (2 * sigma * sigma));
                const nx = (x + dx + W) % W;
                const ny = (y + dy + H) % H;
                sum += src[ny * W + nx] * g;
                w   += g;
              }
            }
            dst[y * W + x] = sum / w;
          }
        }
      }

      // Rank-based void-and-cluster: 3 passes
      for (let pass = 0; pass < 3; pass++) {
        gaussBlur(arr, tmp);
        // Build rank order from blurred image
        const idx = Array.from({length: N}, (_, i) => i);
        idx.sort((a, b) => tmp[a] - tmp[b]);
        // Assign rank-normalized values back
        for (let i = 0; i < N; i++) arr[idx[i]] = (i + 0.5) / N;
      }

      return arr; // values in [0,1], blue-noise distributed
    })();

    // â”€â”€â”€ Dithering â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function buildLuminanceBuffer(t) {
      const lum = new Float32Array(PW * PH);
      for (let py = 0; py < PH; py++) {
        for (let px = 0; px < PW; px++) {
          let v = sampleField(px, py, t);
          v = cursorInfluence(px, py, t, v);
          lum[py * PW + px] = v;
        }
      }
      return lum;
    }

    function applyOrderedDither(lum) {
      const out = new Uint8Array(PW * PH);
      const mat = BAYER[params.matrixSize] || BAYER[4];
      const mSize = mat.length;
      const mMax  = mSize * mSize;
      for (let py = 0; py < PH; py++) {
        for (let px = 0; px < PW; px++) {
          const threshold = (mat[py % mSize][px % mSize] + 0.5) / mMax;
          out[py * PW + px] = lum[py * PW + px] > threshold ? 1 : 0;
        }
      }
      return out;
    }

    function applyBlueNoise(lum) {
      // Spatially stable, temporally smooth â€” threshold against blue noise texture.
      // Tiling the BN_SIZEÃ—BN_SIZE texture over the pixel buffer.
      const out = new Uint8Array(PW * PH);
      for (let py = 0; py < PH; py++) {
        for (let px = 0; px < PW; px++) {
          const bx = px % BN_SIZE;
          const by = py % BN_SIZE;
          const threshold = blueNoise[by * BN_SIZE + bx];
          out[py * PW + px] = lum[py * PW + px] > threshold ? 1 : 0;
        }
      }
      return out;
    }

    function applyVoidCluster(lum) {
      // Blue noise with a slow per-frame phase rotation â€” the texture tiles
      // shift by a small amount each frame, giving a gentle animated texture
      // rather than a locked halftone grid, while staying temporally stable.
      const out  = new Uint8Array(PW * PH);
      const phase = (Date.now() * 0.00003) % 1; // very slow drift
      for (let py = 0; py < PH; py++) {
        for (let px = 0; px < PW; px++) {
          const bx = px % BN_SIZE;
          const by = py % BN_SIZE;
          // Rotate threshold by phase (wraps within [0,1])
          let threshold = (blueNoise[by * BN_SIZE + bx] + phase) % 1;
          out[py * PW + px] = lum[py * PW + px] > threshold ? 1 : 0;
        }
      }
      return out;
    }

    function applyNone(lum) {
      const out = new Uint8Array(PW * PH);
      for (let i = 0; i < lum.length; i++) {
        out[i] = lum[i] > params.threshold ? 1 : 0;
      }
      return out;
    }

    // â”€â”€â”€ Dot renderer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // We draw dot shapes directly onto the offscreen canvas using ctx calls
    // after scaling â€” this gives crisp anti-aliased dots at display resolution.

    function renderDots(out) {
      const scale = params.pixelScale;
      const { r: br, g: bg, b: bb } = params.bgColor;
      const { r: dr, g: dg, b: db } = params.dotColor;

      ctx.fillStyle = `rgb(${br},${bg},${bb})`;
      ctx.fillRect(0, 0, W, H);

      ctx.fillStyle = `rgb(${dr},${dg},${db})`;

      const half   = scale * 0.5;
      const radius = half * params.dotFill;
      const PI2    = Math.PI * 2;

      if (params.dotShape === 'circle') {
        // Batch all circles into one path for performance
        ctx.beginPath();
        for (let py = 0; py < PH; py++) {
          for (let px = 0; px < PW; px++) {
            if (!out[py * PW + px]) continue;
            ctx.moveTo(px * scale + half + radius, py * scale + half);
            ctx.arc(px * scale + half, py * scale + half, radius, 0, PI2);
          }
        }
        ctx.fill('evenodd');
      } else {
        for (let py = 0; py < PH; py++) {
          for (let px = 0; px < PW; px++) {
            if (!out[py * PW + px]) continue;
            const cx = px * scale + half;
            const cy = py * scale + half;
            if (params.dotShape === 'square') {
              ctx.fillRect(cx - radius, cy - radius, radius * 2, radius * 2);
            } else {
              // cross
              const arm = radius * 0.38;
              ctx.fillRect(cx - arm,    cy - radius, arm * 2,    radius * 2);
              ctx.fillRect(cx - radius, cy - arm,    radius * 2, arm * 2);
            }
          }
        }
      }
    }

    // â”€â”€â”€ Main render loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let t = 0;
    let lastPixelScale = params.pixelScale;
    let smoothedLum = null; // temporally smoothed luminance buffer

    function frame(ts) {
      t = ts * 0.001;
      rippleT = Math.min(rippleT + 0.016, 100);

      // Rebuild buffers if scale changed
      if (params.pixelScale !== lastPixelScale) {
        lastPixelScale = params.pixelScale;
        smoothedLum = null;
        resize();
      }

      const rawLum = buildLuminanceBuffer(t);

      // Temporal smoothing: lerp the previous smoothed buffer toward this frame
      if (!smoothedLum || smoothedLum.length !== rawLum.length) {
        smoothedLum = rawLum.slice();
      } else {
        const alpha = params.smoothing;
        for (let i = 0; i < rawLum.length; i++) {
          smoothedLum[i] += (rawLum[i] - smoothedLum[i]) * alpha;
        }
      }

      const lum = smoothedLum;

      let out;
      switch (params.ditherMode) {
        case 'ordered':     out = applyOrderedDither(lum); break;
        case 'bluenoise':   out = applyBlueNoise(lum);     break;
        case 'voidcluster': out = applyVoidCluster(lum);   break;
        default:            out = applyNone(lum);           break;
      }

      // Render dots directly to the display canvas at full resolution
      renderDots(out);

      requestAnimationFrame(frame);
    }

    // â”€â”€â”€ Tweakpane UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const pane = new Tweakpane.Pane({ title: 'Dither Shader', expanded: true });

    // â”€â”€ Pixel Grid â”€â”€
    const gridF = pane.addFolder({ title: 'Pixel Grid', expanded: true });
    gridF.addInput(params, 'pixelScale', {
      label: 'pixel scale', min: 2, max: 20, step: 1
    }).on('change', resize);

    // â”€â”€ Dithering â”€â”€
    const ditherF = pane.addFolder({ title: 'Dithering', expanded: true });
    ditherF.addInput(params, 'ditherMode', {
      label: 'algorithm',
      options: { 'Blue Noise': 'bluenoise', 'Void & Cluster': 'voidcluster', 'Ordered (Bayer)': 'ordered', 'Threshold': 'none' },
    });
    ditherF.addInput(params, 'matrixSize', {
      label: 'Bayer size',
      options: { '2Ã—2': 2, '4Ã—4': 4, '8Ã—8': 8 },
    });
    ditherF.addInput(params, 'threshold', { label: 'threshold', min: 0, max: 1, step: 0.01 });

    // â”€â”€ Luminance Field â”€â”€
    const fieldF = pane.addFolder({ title: 'Luminance Field', expanded: true });
    fieldF.addInput(params, 'fieldMode', {
      label: 'mode',
      options: { 'Plasma': 'plasma', 'Radial': 'radial', 'Noise (FBM)': 'noise', 'Bands': 'bands' },
    });
    fieldF.addInput(params, 'speed',     { min: 0, max: 3,  step: 0.01 });
    fieldF.addInput(params, 'scale',     { min: 0.1, max: 5, step: 0.05 });
    fieldF.addInput(params, 'octaves',   { min: 1, max: 6, step: 1 });
    fieldF.addInput(params, 'contrast',  { min: 0.1, max: 4, step: 0.05 });
    fieldF.addInput(params, 'bias',      { min: -0.5, max: 0.5, step: 0.01 });
    fieldF.addInput(params, 'smoothing', { label: 'smoothing', min: 0.01, max: 1, step: 0.01 });

    // â”€â”€ Cursor â”€â”€
    const cursorF = pane.addFolder({ title: 'Cursor Interaction', expanded: true });
    cursorF.addInput(params, 'cursorMode', {
      label: 'mode',
      options: { 'Brighten': 'brighten', 'Darken': 'darken', 'Invert': 'invert', 'Ripple': 'ripple' },
    });
    cursorF.addInput(params, 'cursorRadius',   { label: 'radius',   min: 20, max: 400, step: 5 });
    cursorF.addInput(params, 'cursorStrength', { label: 'strength', min: 0,  max: 1,   step: 0.01 });

    // â”€â”€ Dot Shape â”€â”€
    const dotF = pane.addFolder({ title: 'Dot Shape', expanded: false });
    dotF.addInput(params, 'dotShape', {
      label: 'shape',
      options: { 'Circle': 'circle', 'Square': 'square', 'Cross': 'cross' },
    });
    dotF.addInput(params, 'dotFill', { label: 'fill', min: 0.1, max: 1, step: 0.01 });

    // â”€â”€ Colors â”€â”€
    const colorF = pane.addFolder({ title: 'Colors', expanded: false });
    colorF.addInput(params, 'dotColor', { label: 'dot' });
    colorF.addInput(params, 'bgColor',  { label: 'background' });

    // â”€â”€ Copy Code â”€â”€
    pane.addSeparator();
    const btn = pane.addButton({ title: 'ðŸ“‹ Copy code' });
    btn.on('click', () => {
      // Bake current params into a self-contained copy of the page source,
      // with the params block replaced by the live values.
      fetch(window.location.href)
        .then(r => r.text())
        .then(src => {
          // Patch the params literal with current live values
          const patched = src.replace(
            /const params = \{[\s\S]*?\};(\s*\/\/ â”€â”€â”€ Mouse)/,
            'const params = ' + JSON.stringify(params, null, 6) + ';$1'
          );
          return navigator.clipboard.writeText(patched);
        })
        .then(() => {
          btn.title = 'âœ… Copied!';
          setTimeout(() => { btn.title = 'ðŸ“‹ Copy code'; }, 2000);
        })
        .catch(() => {
          // Fallback: copy params JSON only
          navigator.clipboard.writeText(JSON.stringify(params, null, 2));
        });
    });

    // â”€â”€â”€ Preset system â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const STORAGE_KEY = 'dither-shader-presets';

    function loadAllPresets() {
      try { return JSON.parse(localStorage.getItem(STORAGE_KEY)) || {}; }
      catch { return {}; }
    }

    function saveAllPresets(presets) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(presets));
    }

    function snapParams() {
      return JSON.parse(JSON.stringify(params));
    }

    function applyPreset(snapshot) {
      Object.assign(params, snapshot);
      pane.refresh();
      smoothedLum = null; // reset smoothing buffer so new params take effect immediately
    }

    function toast(msg, color = '#2d6af0') {
      const el = document.getElementById('preset-toast');
      el.textContent = msg;
      el.style.background = color;
      el.classList.add('show');
      clearTimeout(el._t);
      el._t = setTimeout(() => el.classList.remove('show'), 1800);
    }

    function renderPresetList() {
      const list = document.getElementById('preset-list');
      const presets = loadAllPresets();
      const names = Object.keys(presets);
      list.innerHTML = '';

      if (names.length === 0) {
        list.innerHTML = '<div id="preset-empty">No presets saved yet.</div>';
        return;
      }

      names.forEach(name => {
        const item = document.createElement('div');
        item.className = 'preset-item';

        const loadBtn = document.createElement('button');
        loadBtn.className = 'preset-load-btn';
        loadBtn.textContent = name;
        loadBtn.title = 'Load "' + name + '"';
        loadBtn.addEventListener('click', () => {
          applyPreset(presets[name]);
          toast('Loaded "' + name + '"');
        });

        const exportBtn = document.createElement('button');
        exportBtn.className = 'preset-export-btn';
        exportBtn.textContent = 'â¬‡';
        exportBtn.title = 'Export "' + name + '" as JSON';
        exportBtn.addEventListener('click', () => {
          const json = JSON.stringify({ [name]: presets[name] }, null, 2);
          const a = document.createElement('a');
          a.href = URL.createObjectURL(new Blob([json], { type: 'application/json' }));
          a.download = 'dither-preset-' + name.replace(/\s+/g, '-') + '.json';
          a.click();
          toast('Exported "' + name + '"');
        });

        const delBtn = document.createElement('button');
        delBtn.className = 'preset-delete-btn';
        delBtn.textContent = 'âœ•';
        delBtn.title = 'Delete "' + name + '"';
        delBtn.addEventListener('click', () => {
          const all = loadAllPresets();
          delete all[name];
          saveAllPresets(all);
          renderPresetList();
          toast('Deleted "' + name + '"', '#a00');
        });

        item.appendChild(loadBtn);
        item.appendChild(exportBtn);
        item.appendChild(delBtn);
        list.appendChild(item);
      });
    }

    // Save button
    document.getElementById('preset-save-btn').addEventListener('click', () => {
      const input = document.getElementById('preset-name-input');
      const name = input.value.trim();
      if (!name) { input.focus(); return; }
      const all = loadAllPresets();
      all[name] = snapParams();
      saveAllPresets(all);
      renderPresetList();
      input.value = '';
      toast('Saved "' + name + '"');
    });

    // Save on Enter
    document.getElementById('preset-name-input').addEventListener('keydown', e => {
      if (e.key === 'Enter') document.getElementById('preset-save-btn').click();
    });

    // Import JSON
    document.getElementById('preset-import-btn').addEventListener('click', () => {
      document.getElementById('preset-import-file').click();
    });
    document.getElementById('preset-import-file').addEventListener('change', e => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = ev => {
        try {
          const imported = JSON.parse(ev.target.result);
          const all = loadAllPresets();
          let count = 0;
          for (const [name, snap] of Object.entries(imported)) {
            all[name] = snap;
            count++;
          }
          saveAllPresets(all);
          renderPresetList();
          toast('Imported ' + count + ' preset' + (count !== 1 ? 's' : ''));
        } catch {
          toast('Invalid JSON file', '#a00');
        }
      };
      reader.readAsText(file);
      e.target.value = '';
    });

    // Initial render
    renderPresetList();

    // â”€â”€â”€ Init & start â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    resize();
    requestAnimationFrame(frame);

  }); // DOMContentLoaded
  </script>
</body>
</html>
